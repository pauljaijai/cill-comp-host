<template>
  <div class=" relative overflow-hidden">
    <canvas
      ref="canvasRef"
      class=" absolute left-0 top-0 w-full h-full"
    />

    <div class=" absolute left-0 top-0 p-4 text-white">
      {{ fps }}
    </div>
  </div>
</template>


<script setup lang="ts">
import { ref, shallowRef } from 'vue';
import {
  ArcRotateCamera,
  Color3,
  Color4,
  DefaultRenderingPipeline,
  DepthOfFieldEffectBlurLevel,
  DynamicTexture, Matrix, Mesh, MeshBuilder,
  Particle,
  ParticleSystem, Animation,
  StandardMaterial, Texture, Vector3,
  CubicEase,
  EasingFunction,
  SineEase,
  QuadraticEase,
  QuinticEase,
  UniversalCamera,
  IAnimationKey
} from '@babylonjs/core';
import { clone, map, pipe, sum } from 'remeda';
import anime from 'animejs';

import { InitParam, useBabylonScene } from '../../composables/use-babylon-scene';
import { useIntervalFn } from '@vueuse/core';

import '@babylonjs/core/Debug/debugLayer';
import '@babylonjs/inspector';

interface ImageInfo {
  src: string;
  offset: Vector3;
  duration: number;
}

// #region Props
interface Props {
  images?: Array<ImageInfo | string>;
  /** 自動播放。若為 true，則預設每 5s 切換一次；
   * number 則可自行指定毫秒。
   */
  autoplay?: boolean | number;
  fpsVisible?: boolean;
}
// #endregion Props
const props = withDefaults(defineProps<Props>(), {
  images: () => [],
  autoplay: false,
  fpsVisible: false,

});

// #region Emits
// const emit = defineEmits<{
//   'update:modelValue': [value: Props['modelValue']];
// }>();
// #endregion Emits

const fps = ref(0);
useIntervalFn(() => {
  fps.value = Math.floor(engine.value?.getFps() ?? 0);
}, 100);

const currentIndex = ref(0);
const boards = shallowRef<Mesh[]>([]);

const { canvasRef, engine, camera, scene } = useBabylonScene({
  createCamera(param) {
    const { scene } = param;
    const camera = new UniversalCamera('camera', new Vector3(0, 0, -10), scene);

    return camera;
  },
  async init(param) {
    const { canvas, camera, scene } = param;

    scene.clearColor = new Color4(0, 0, 0, 0);

    // camera.attachControl(canvas, true);

    // scene.debugLayer.show();

    initRenderingPipeline(param);
    boards.value = await initBoards(param);
    focusBoard(currentIndex.value);
  },
});

function initRenderingPipeline(
  { scene, camera }: InitParam,
) {
  const pipeline = new DefaultRenderingPipeline(
    'defaultPipeline',
    true,
    scene,
    [camera]
  );

  pipeline.depthOfFieldEnabled = true;
  pipeline.depthOfField.focusDistance = 2 * 1000;
  pipeline.depthOfField.focalLength = 100000;
  pipeline.depthOfField.fStop = 32;
  pipeline.depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;

  pipeline.bloomEnabled = true;

  return pipeline;
}


const OFFSET = 5;
async function initBoards(
  { scene }: InitParam
) {
  const boards = await pipe(
    props.images,
    map.indexed((item, i) => new Promise((resolve) => {
      const src = pipe(
        item,
        (data) => {
          if (typeof data === 'string') {
            return data;
          }

          return data.src
        },
      );

      const texture = new Texture(src, scene);

      texture.onLoadObservable.add(() => {
        const { width, height } = texture.getSize();

        /** 根據圖片比例產生 plane */
        const board = MeshBuilder.CreatePlane(`board-${i}`, {
          width: width / height, height: 1,
        });
        board.position = new Vector3(
          Math.random() * OFFSET - OFFSET / 2,
          Math.random() * OFFSET - OFFSET / 2,
          Math.random() * OFFSET - OFFSET / 2,
        );

        const rotateZ = Math.PI / 2 * (i % 2);
        board.rotation = new Vector3(0, 0, rotateZ);

        const material = new StandardMaterial(`material-${i}`, scene);
        material.diffuseTexture = texture;

        material.disableLighting = true;
        material.emissiveColor = new Color3(1, 1, 1);

        board.material = material;

        resolve(board);
      })
    })),
    async (tasks) => {
      const results = await Promise.allSettled(tasks);

      return results
        .filter((result): result is PromiseFulfilledResult<Mesh> =>
          result.status === 'fulfilled'
        )
        .map(({ value }) => value);
    },
  )
  return boards;
}

const defaultImageInfo: Omit<ImageInfo, 'src'> = {
  offset: new Vector3(0, 0, 0),
  duration: 3000,
}
async function focusBoard(index: number) {
  const currentCamera = camera.value;
  const currentScene = scene.value;
  if (!currentCamera || !currentScene) return;
  if (!(currentCamera instanceof UniversalCamera)) return;

  const board = boards.value[index];
  const info = pipe(
    props.images[index],
    (data) => {
      if (!data || typeof data === 'string') {
        return defaultImageInfo;
      }

      return {
        ...clone(defaultImageInfo),
        ...data,
      }
    },
  );
  if (!board) return;

  const { x, y, z } = board.position;
  const { z: rotateZ } = board.rotation;

  // 鏡頭移動動畫
  anime.remove(currentCamera.position);
  anime.remove(currentCamera.rotation);

  const { offset } = info;
  await Promise.all([
    anime({
      targets: currentCamera.position,
      x: [
        {
          value: x + offset.x,
          easing: 'easeInOutQuart',
        }
      ],
      y: [
        {
          value: y + offset.y,
          easing: 'easeInOutQuart',
        }
      ],
      z: [
        {
          value: sum([
            (z - currentCamera.position.z) / 2,
            currentCamera.position.z,
            -5,
            offset.z,
          ]),
          easing: 'easeInOutQuart',
        },
        {
          value: z - 2,
          easing: 'easeInOutQuart',
        }
      ],
      duration: info.duration,
    }).finished,
    anime({
      targets: currentCamera.rotation,
      z: [
        {
          value: rotateZ,
          easing: 'easeInOutQuart',
        }
      ],
      duration: info.duration,
    }).finished
  ])
}

function next() {
  currentIndex.value = (currentIndex.value + 1) % props.images.length;
  focusBoard(currentIndex.value);
}

// #region Methods
defineExpose({
  next,
});
// #endregion Methods
</script>

<style scoped lang="sass">
</style>
